<!DOCTYPE html><html lang="en-en"><head><title>Samuel E. Giddins</title><meta charset="utf-8" /><meta content="samuel giddins" name="keywords" /><meta content="IE=edge" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="" name="description" /><meta content="" name="author" /><meta content="True" name="HandheldFriendly" /><meta content="320" name="MobileOptimized" /><link href="../../../../stylesheets/app.css" rel="stylesheet" type="text/css" /><script src="../../../../scripts/app.js" type="text/javascript"></script></head><body class="home blog"><div id="container"><header class="header"><div class="wrap clearfix" id="inner-header"><div class="h1" id="site-title"><a href="//segiddins.me" rel="nofollow">Samuel E. Giddins</a></div><div id="site-description"><h2>UChicago 2018. Realm. CocoaPods.</h2></div><section class="social wrap"><div><a class="symbol" href="https://github.com/segiddins" rel="me" title="&#xe036;"></a><a class="symbol" href="mailto:segiddins@segiddins.me" rel="me" title="&#xe024;"></a><a class="symbol" href="tel:9178873993" rel="me" title="&#xe049;"></a><a href='https://twitter.com/segiddins' rel="me" class='symbol' title='&#xe086;'></a><a href='https://linkedin.com/in/segiddins' rel="me" class='symbol' title='&#xe052;'></a></div></section><nav id="site-navigation"><ul><li><a href="//segiddins.me">About Me</a></li><li><a href="//blog.segiddins.me">Blog</a></li><li><a href="//blog.segiddins.me/rss">RSS</a></li></ul></nav></div></header><article class="wrap hentry clearfix"><header class="article-header"><h1 class="h2"><h2 class="h2"><a href="/2015/01/25/dynamic-casting-in-swift/" title="Dynamic Casting in Swift">Dynamic Casting in Swift</a></h2></h1><p class="byline vcard"><span>By </span><span class="author">Samuel E. Giddins</span><span> on </span><time class="updated">Sunday January 25th, 2015</time></p></header><section class="entry-content clearfix"><p>We’ve been spoiled by Objective-C’s runtime flexibility. Its tendency for dynamic dispatch, as well as a very powerful runtime (that’s exposed via both Objective-C and C APIs) has meant that dealing with arbitrary data was an easy task. You just check <code>[object isKindOfClass:klass]</code> and accept <code>id</code> parameters and everything works as expected.</p>

<p>In Swift, however, we have a statically-typed language where the compiler really needs us to know types at compile-time, rather than runtime. In general, this helps us write safer code than was possible in Objective-C, but makes dealing with data this is <em>fundamentally untyped</em> a real challenge. Swift has two operators that help to bridge the gap between static safety and the power of dynamicism: <code>as</code> and <code>as?</code>.</p>



<p>It might help to pretend that those two operators are functions, so here are their function signatures:</p>
<pre><code class="highlight plaintext">func as&lt;T, U&gt;(lhs: T, rhs: U.Type) -&gt; U

func as?&lt;T, U&gt;(lhs: T, rhs: U.Type) -&gt; U?
</code></pre>

<p>The first operator, <code>as</code>, lets us give an object of type <code>T</code> and tell the compiler, &lsquo;no, at runtime this <em>really</em> will be a <code>U</code>&rsquo;. This is really handy when dealing with Objective-C methods that return <code>id</code> or Swift functions that return <code>AnyObject</code>, but the programmer knows at compile time what their <em>real</em> type will be.</p>

<p>The second operator, <code>as?</code>, is probably the more interesting of the two. <code>as?</code> lets us write <em>dynamic, conditional</em> code that is truly native to the static Swift world. <code>as?</code> allows us to tell the compiler, ‘I don’t really know what this object will be at runtime, but if it happens to be of type <code>U</code>, I want it as a type-safe object of that type. Otherwise, I’ll take <code>nil</code>.’ This is super powerful. Imagine that we’re writing an application that consumes a REST API. The data that API returns is <em>fundamentally untyped</em> since the compiler has absolutely no visibility into the type of data it can return. We’re interested in pulling out a <code>count</code> property from that API response, but the <code>count</code> property on our model needs to be of type <code>Int</code> &ndash; how do we bridge that gap? Enter <code>as?</code>. We want to take the response’s <code>count</code> as an <code>Int</code>, but only if it really <em>is</em> an <code>Int</code>:</p>
<pre><code class="highlight plaintext">let count = json["count"] as? Int // count: Int?
</code></pre>

<p>We can even define some syntactic sugar on top of this type verification:</p>
<pre><code class="highlight plaintext">func id&lt;U&gt;(object: AnyObject) -&gt; U? {
  if let typed = object as? U {
    return typed
  }
  return nil
}
</code></pre>

<p>Now, we can just write:</p>
<pre><code class="highlight plaintext">let count = id(json["count"]) as Int?
</code></pre>

<p>OK, that last example might not look like a huge improvement, but coupled with Swift&rsquo;s powerful type inference, you can &#39;magically&rsquo; <code>type</code> objects at runtime with a single function call.</p>

<p>For example, the <code>id</code> function can be used when passing the extracted value into a typed function:</p>
<pre><code class="highlight plaintext">func doubleMaybe(i: Int?) -&gt; Int? {
    if let i = i {
        return i * 2
    }
    return nil
}

// Note that we don't have to explicitly cast to Int?
let doubleCount2 = doubleMaybe(id(json["count"]))
</code></pre>

<p>This gives us the best of both worlds: the ability to dynamically handle data that is out of our control, and being able to do so in a convenient way that is perfectly type-safe.</p>

<p><em>nota bene</em>: So, we have these two operators that look to be <em>basically</em> the same &ndash; they only differ by one letter, after all. What’s the difference between them? Turns out, the difference is <em>massive</em>. If we do <code>x as? U</code>, our program (presuming it compiles) will <em>never</em> crash &ndash; you’ll get back <code>nil</code> if <code>x</code> is not a subtype of <code>U</code>. On the other hand, <code>x as U?</code> (or <code>x as U</code>) will cause our program to segfault if <code>x</code> is anything other than a subtype of <code>U?</code>(or <code>U</code>).</p>
</section><footer class="article-footer"></footer></article><footer class="container footer"><div class="clearfix" id="inner-footer"><section class="recent wrap sevencol first clearfix"><nav class="pagination"><a class="newer-posts" href="/2014/12/05/thanks-again-stripe/">&larr; Previous</a><span class="page-number">Page 37 of 37</span><p><a href="//blog.segiddins.me/archive">Archive</a></p></nav></section><section class="sidebar fivecol clearfix"><header class="sidebar-header"><h3>Samuel E. Giddins</h3><h4>UChicago 2018. Realm. CocoaPods.</h4></header><nav class="sidebar-menu vertical"><ul><li><a href="//segiddins.me">About Me</a><span> | </span></li><li><a href="//blog.segiddins.me">Blog</a><span> | </span></li><li><a href="//blog.segiddins.me/rss">RSS</a></li></ul></nav><section class="social wrap"><div><a class="symbol" href="https://github.com/segiddins" rel="me" title="&#xe036;"></a><a class="symbol" href="mailto:segiddins@segiddins.me" rel="me" title="&#xe024;"></a><a class="symbol" href="tel:9178873993" rel="me" title="&#xe049;"></a><a href='https://twitter.com/segiddins' rel="me" class='symbol' title='&#xe086;'></a><a href='https://linkedin.com/in/segiddins' rel="me" class='symbol' title='&#xe052;'></a></div></section></section></div><div class="source-og copyright"><span>© 2012-2015 </span><a href="//segiddins.me">Samuel E. Giddins</a></div></footer></div></body></html>