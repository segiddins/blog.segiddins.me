<!DOCTYPE html><html lang="en-en"><head><title>Dynamic Casting in Swift</title><meta charset="utf-8" /><meta content="samuel giddins" name="keywords" /><meta content="IE=edge" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="" name="description" /><meta content="" name="author" /><meta content="True" name="HandheldFriendly" /><meta content="320" name="MobileOptimized" /><link href="../../../../stylesheets/app.css" rel="stylesheet" type="text/css" /><script src="../../../../scripts/app.js" type="text/javascript"></script></head><body class="home blog"><div id="container"><header class="header"><div class="wrap clearfix" id="inner-header"><div class="h1" id="site-title"><a href="//segiddins.me" rel="nofollow">Samuel Giddins</a></div><div id="site-description"><h2>Staff Software Engineer</h2></div><section class="social wrap"><div><a class="symbol" href="https://github.com/segiddins" rel="me" title="&#xe237;"></a><a class="symbol" href="mailto:segiddins@segiddins.me" rel="me" title="&#xe024;"></a><a class="symbol" href="tel:9178873993" rel="me" title="&#xe049;"></a><a href='https://www.linkedin.com/in/segiddins' rel="me" class='symbol' title='&#xe052;'></a></div></section><nav id="site-navigation"><ul><li><a href="//segiddins.me">About Me</a></li><li><a href="//blog.segiddins.me">Blog</a></li><li><a href="//blog.segiddins.me/rss">RSS</a></li></ul></nav></div></header><article class="wrap hentry clearfix"><header class="article-header"><h1 class="h2"><h2 class="h2"><a href="/2015/01/25/dynamic-casting-in-swift/" title="Dynamic Casting in Swift">Dynamic Casting in Swift</a></h2></h1><p class="byline vcard"><span>By </span><span class="author"><a href="https://twitter.com/segiddins">Samuel Giddins</a></span><span> on </span><time class="updated">Sunday, January 25th, 2015</time></p></header><section class="entry-content clearfix"><p>We’ve been spoiled by Objective-C’s runtime flexibility. Its tendency for dynamic dispatch, as well as a very powerful runtime (that’s exposed via both Objective-C and C APIs) has meant that dealing with arbitrary data was an easy task. You just check <code>[object isKindOfClass:klass]</code> and accept <code>id</code> parameters and everything works as expected.</p>

<p>In Swift, however, we have a statically-typed language where the compiler really needs us to know types at compile-time, rather than runtime. In general, this helps us write safer code than was possible in Objective-C, but makes dealing with data this is <em>fundamentally untyped</em> a real challenge. Swift has two operators that help to bridge the gap between static safety and the power of dynamicism: <code>as</code> and <code>as?</code>.</p>



<p>It might help to pretend that those two operators are functions, so here are their function signatures:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="k">as</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">U</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">U</span>

<span class="kd">func</span> <span class="k">as?</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">U</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">?</span>
</code></pre>

<p>The first operator, <code>as</code>, lets us give an object of type <code>T</code> and tell the compiler, &lsquo;no, at runtime this <em>really</em> will be a <code>U</code>&rsquo;. This is really handy when dealing with Objective-C methods that return <code>id</code> or Swift functions that return <code>AnyObject</code>, but the programmer knows at compile time what their <em>real</em> type will be.</p>

<p>The second operator, <code>as?</code>, is probably the more interesting of the two. <code>as?</code> lets us write <em>dynamic, conditional</em> code that is truly native to the static Swift world. <code>as?</code> allows us to tell the compiler, ‘I don’t really know what this object will be at runtime, but if it happens to be of type <code>U</code>, I want it as a type-safe object of that type. Otherwise, I’ll take <code>nil</code>.’ This is super powerful. Imagine that we’re writing an application that consumes a REST API. The data that API returns is <em>fundamentally untyped</em> since the compiler has absolutely no visibility into the type of data it can return. We’re interested in pulling out a <code>count</code> property from that API response, but the <code>count</code> property on our model needs to be of type <code>Int</code> &ndash; how do we bridge that gap? Enter <code>as?</code>. We want to take the response’s <code>count</code> as an <code>Int</code>, but only if it really <em>is</em> an <code>Int</code>:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">count</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s">"count"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">Int</span> <span class="c1">// count: Int?</span>
</code></pre>

<p>We can even define some syntactic sugar on top of this type verification:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="n">id</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">object</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">typed</span> <span class="o">=</span> <span class="n">object</span> <span class="k">as?</span> <span class="kt">U</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">typed</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>

<p>Now, we can just write:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">count</span> <span class="o">=</span> <span class="nf">id</span><span class="p">(</span><span class="n">json</span><span class="p">[</span><span class="s">"count"</span><span class="p">])</span> <span class="k">as</span> <span class="kt">Int</span><span class="p">?</span>
</code></pre>

<p>OK, that last example might not look like a huge improvement, but coupled with Swift&rsquo;s powerful type inference, you can &lsquo;magically&rsquo; <code>type</code> objects at runtime with a single function call.</p>

<p>For example, the <code>id</code> function can be used when passing the extracted value into a typed function:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">doubleMaybe</span><span class="p">(</span><span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">i</span> <span class="o">=</span> <span class="n">i</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// Note that we don't have to explicitly cast to Int?</span>
<span class="k">let</span> <span class="nv">doubleCount2</span> <span class="o">=</span> <span class="nf">doubleMaybe</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">json</span><span class="p">[</span><span class="s">"count"</span><span class="p">]))</span>
</code></pre>

<p>This gives us the best of both worlds: the ability to dynamically handle data that is out of our control, and being able to do so in a convenient way that is perfectly type-safe.</p>

<p><em>nota bene</em>: So, we have these two operators that look to be <em>basically</em> the same &ndash; they only differ by one letter, after all. What’s the difference between them? Turns out, the difference is <em>massive</em>. If we do <code>x as? U</code>, our program (presuming it compiles) will <em>never</em> crash &ndash; you’ll get back <code>nil</code> if <code>x</code> is not a subtype of <code>U</code>. On the other hand, <code>x as U?</code> (or <code>x as U</code>) will cause our program to segfault if <code>x</code> is anything other than a subtype of <code>U?</code>(or <code>U</code>).</p>
</section><footer class="article-footer"></footer></article><footer class="container footer"><div class="clearfix" id="inner-footer"><section class="recent wrap sevencol first clearfix"><nav class="pagination"><a class="newer-posts" href="/2014/12/05/thanks-again-stripe/">&larr; Previous</a><span class="page-number">Page 37 of 58</span><a class="older-posts" href="/2015/02/12/my-problem-with-twitter/">Next &rarr;</a><p><a href="//blog.segiddins.me/archive">Archive</a></p></nav></section><section class="sidebar fivecol clearfix"><header class="sidebar-header"><h3>Samuel Giddins</h3><h4>Staff Software Engineer</h4></header><nav class="sidebar-menu vertical"><ul><li><a href="//segiddins.me">About Me</a><span> | </span></li><li><a href="//blog.segiddins.me">Blog</a><span> | </span></li><li><a href="//blog.segiddins.me/rss">RSS</a></li></ul></nav><section class="social wrap"><div><a class="symbol" href="https://github.com/segiddins" rel="me" title="&#xe237;"></a><a class="symbol" href="mailto:segiddins@segiddins.me" rel="me" title="&#xe024;"></a><a class="symbol" href="tel:9178873993" rel="me" title="&#xe049;"></a><a href='https://www.linkedin.com/in/segiddins' rel="me" class='symbol' title='&#xe052;'></a></div></section></section></div><div class="source-og copyright"><span>© 2012-2024 </span><a href="//segiddins.me">Samuel Giddins</a></div></footer></div></body></html>